# 原文
[QUIC](https://tools.ietf.org/html/draft-hamilton-early-deployment-quic-00)

# 2. 协定和一些定义 #
QUIC使用的所有整型数值都使用小端字节序而非网络序，包括长度值，版本号，类型等。QUIC对于动态大小的数据帧的类型并不强制要求对齐。  

以下是文章中使用的一些术语：  

- 客户端：QUIC连接的发起者端点。  
- 服务端：接受到来的QUIC连接的端点。  
- 终端：一个客户端或者服务端的连接的终点。  
- 流：在QUIC连接中通过特定的逻辑信道传递的双向数据流。  
- 连接：两个QUIC终端的会话，多路流在同一个连接将使用同一种加密方法。  
- 连接ID：QUIC连接的标识符。  
- QUIC包：一个可以被接受端解析的合法的UDP载荷。本文档中QUIC包大小可以参考UDP载荷大小。  

# 3. QUIC综述 #
这节我们要描述QUIC的主要机制和优势。QUIC机制上类似TCP+TLS+HTTP/2，但是是基于UDP的实现。QUIC和TCP+TLS+HTTP/2相比，优势如下：  

- 连接建立的延迟  
- 灵活的拥塞控制  
- 消除了head-of-line blocking的多路复用。[[HOL](https://en.wikipedia.org/wiki/Head-of-line_blocking)]  
- 经认证且加密的消息头和载荷  
- 流和连接的流量控制  
- 连接迁移  

## 3.1 连接建立的延迟 ##
QUIC合并了加密和传输握手，降低了建立加密连接所需要的消息交互来回次数。传统的TCP+TLS在发送数据之前需要经历1-3个来回的信息交互。与之相比，QUIC连接一般是0-RTT的，大部分QUIC连接，数据将被直接发送，不需要等待服务端的响应。  

QUIC使用了专用流(STREAM ID 1)来执行握手，但是具体的握手协议本文不进行描述。具体详见参考文档[2].QUIC当前的握手方式将在未来被TLS 1.3所替代。  

注：[[TLS 1.3 Zero-RTT](https://tlswg.github.io/tls13-spec/)]

## 3.2 灵活的拥塞控制 ##
QUIC拥有可插拔的拥塞控制，和TCP相比，提供了更丰富的信令，这让QUIC可以为拥塞控制算法提供更多的信息。当前默认的拥塞控制与TCP相同。我们正在实验一些可以替代TCP的拥塞控制算法。

举其中一个例子，我们在所有包(包括普通包和重传包)种加入了一个新的包序列号。这使得QUIC的发送方可以区分重传和普通的ACK报文，可以避免TCP的重传二义性问题(注：无法判断ACK响应的是普通包还是重传包，会影响RTT计算的精度，进而影响RTO)。QUIC的ACK报文携带了从包被接收到确认报文被发送的延迟，以及一个单调递增的包号，这些都可以提高RTT的计算精度。  

最后，QUIC的ACK帧支持最多256个ack块，因此QUIC在重排上相较于TCP的SACK更加具有弹性(注：SACK貌似每次发送SACK报文时候最多只能携带四组分组缺失信息)，也可以在丢包或者乱序时候保持更多的包(拥有更大的缓冲区)。同时客户端和服务端也都能更准确的知道对端的接收信息。  

## 3.3 流和连接的流量控制 ##

QUIC实现了流和连接级别的流量控制，与HTTP/2的流量控制类似。QUIC的流级别流量控制工作如下：一个QUIC接收端公布自己希望接收的最大数据偏移(注：单个连接中的多路复用，在一个数据流中，每个QUIC流具有自己的一个偏移)，当数据在某一条流中传输时，接收方发送WINDOW_UPDATE帧增加自己这条流的最大接收数据量，发送方可以相应的增加这条流上的数据发送量。  

除了每条流的流控外，QUIC还实现了连接级别的流量控制，根据接收端自己为每条连接分配的资源来限制总的buffer数量。连接级别的流量控制工作模式上和流的流量控制相同，不过分发和最大接收的字节是所有流的总和。  

类似于TCP接收窗口的自动调节，QUIC也实现了在流级别和连接级别的流量控制配额的自动调节。QUIC的自动调节会增加每一个WINDOW_UPDATE帧中的配额大小，限制发送端的速率，也可以在接收端应用速度慢的时候减少发送端的速率。  

## 3.4 多路复用 ##

基于TCP的HTTP/2会遇到HOL阻塞问题。因为HTTP/2将多个流在一个TCP连接上传输，一个TCP数据段的丢失会导致所有之后的数据段在重传包到来之前被阻塞，而无法顾及之后HTTP/2流中的被封装的其他数据端。  

因为QUIC被设计为多路复用操作，一个单独的流丢失的包所承载的数据一般只影响特定的流。每个流的帧在达到时可以被立刻分配到对应的流上，因此流没有数据丢失的时候可以持续组装并上报至应用层。

警告：QUIC当前通过HTTP/2 HPACK[[HPACK](https://tools.ietf.org/html/draft-ietf-httpbis-header-compression-06)]压缩HTTP头，这会导致HTTP头部帧的HOL。  

**注：消除了HOL可能是因为流是QUIC的内容，可以对流进行区分。而TCP不识别载荷的内容。**

## 3.5 可靠及加密的头部和载荷  ##

由于TCP头部在信道上是明文传输且未经过验证的，因此导致了许多注入和头部伪造的问题，比如接收窗口伪造和序列号重写的问题。当其中的一些攻击激活时，其他用于网络中的一些中间件的类似机制有时正在透明的提高TCP性能。然而，即使这些中间件正在增强TCP性能，但是仍然限制着传输协议的可进化性(原文：However, even "performance-enhancing" middleboxes still effectively limit the evolvability of the transport protocol，个人理解为TCP性能的演进)，正如从MPTCP(multi-path tcp)及其后续的部署问题。  
**注：个人理解，当某些攻击生效时，可能会破坏TCP的公平性，甚至会占满整个机器上的带宽。如伪造TCP连接，伪造ACK，使TCP认为链路状态较好，并不断提升该链路性能，导致其他链路质量下降。**    

QUIC包总是经过认证，且其载荷都是经过加密的。QUIC包头的一部分没有经过加密，但是这一部分会通过接收端进行验证，因此可以阻止第三方对任何包进行注入或者篡改。QUIC能保护端到端通信中那些受到有意或者无意的第三方篡改的连接。  

警告：重置一个连接的PUBLIC_RESET包当前是未验证的。  

## 3.6 连接迁移 ##

TCP连接由源地址、源端口、目的地址、目的端口这个四元组标识。TCP连接在IP改变(如wifi切换为蜂窝信号)或者端口改变(如客户端NAT端口绑定过期导致服务端可见的对端端口改变)时无法保持连接是一个众所周知的问题。当MPTCP面对TCP连接迁移的问题时，仍旧会因为缺少中间件的支持和操作系统的调度而变得麻烦。  

QUIC连接由客户端随机生成的一个64位连接标识符标记。当地址发生变化或者NAT重新绑定，这个连接标识符在这次连接迁移中保持不变，因此QUIC可以通过这种机制保持链路存活。QUIC同样提供了自动加密的认证，因此一个迁移后的客户端仍然可以使用相同的会话键值来对包进行加密解密。  

在一些场景下，当连接明通过四元组明确标识时，比如服务端使用一个临时端口向客户端发送报文，此时可以配置成为不发送连接标识符来节约网络流量。  

# 4. 包类型及格式 #

QUIC包分为普通包和特殊包。其中特殊包包含两类，版本协商包和公共重置包。所有QUIC包都应该被限制大小以适应路径MTU，防止IP层分片。路径MTU发现是一项正在进行的工作，当前QUIC针对IPV6使用1350字节最大包大小，IPV4使用1370包大小，两个大小均不包含IP和UDP开销。

## 4.1 QUIC公共包头 ##

所有QUIC包的数据格式都有一个2到19字节的公共头。公共头的数据格式如下：

	     0        1        2        3        4            8
	+--------+--------+--------+--------+--------+---    ---+
	| 公共   |    连接标识  (0 or 64)    ...                 | ->
	|标志(8) |      (可变长度)                               |
	+--------+--------+--------+--------+--------+---    ---+

	     9       10       11        12
	+--------+--------+--------+--------+
	|      QUIC 版本号 (32)              | ->
	|         (可选)                     |
	+--------+--------+--------+--------+

	    13       14       15        16      17       18       19       20
	+--------+--------+--------+--------+--------+--------+--------+--------+
	|                            多种特殊场景                                | ->
	|                              （可选）                                  |
	+--------+--------+--------+--------+--------+--------+--------+--------+

	    21       22       23        24      25       26       27       28
	+--------+--------+--------+--------+--------+--------+--------+--------+
	|                         多种特殊场景后续部分                            | ->
	|                              (可选)                                   |
	+--------+--------+--------+--------+--------+--------+--------+--------+
	
	    29       30       31        32      33       34       35       36
	+--------+--------+--------+--------+--------+--------+--------+--------+
	|                         多种特殊场景后续部分                            | ->
	|                              (可选)                                   |
	+--------+--------+--------+--------+--------+--------+--------+--------+
	
	    37       38       39        40      41       42       43       44
	+--------+--------+--------+--------+--------+--------+--------+--------+
	|                         多种特殊场景后续部分                            | ->
	|                              (可选)                                   |
	+--------+--------+--------+--------+--------+--------+--------+--------+
	
	
	    45      46       47        48       49       50
	+--------+--------+--------+--------+--------+--------+
	|           包序号 (8, 16, 32, or 48)                  |
	|                  (可变长度)                          |
	+--------+--------+--------+--------+--------+--------+

载荷中可能包含多种下述若干字节的类型依赖的包头。

公共头字段描述如下：

- 公共标志位：

 - 0x01 = PUBLIC\_FLAG\_VERSION. 这个标志位的解释取决于这个包是由服务端发出的还是客户端发出的。如果是客户端发出的，设置了这个标志位表明这个头部包含了QUIC版本号信息（见下）。在服务端确认接受客户端请求的版本之前，客户端发送的所有包都必须要设置这个标志位。服务端接受这个版本则会发送未设置这个标志位的包。如果服务端设置了这个标志位，那么这么包就是一个版本协商包。版本协商将在后面具体描述。  
 - 0x02 = PUBLIC\_FLAG\_RESET. 设置了这个标志位表明这个包是一个重置包。  
 - 0x04 = 表明该头部中存在一个32字节大小的多种特殊场景信息。  
 - 0x08 = 表明该包中包含了完整的8字节大小的连接标识符。这个标志位必须一直被设置，直到在某个数据方向上协商出一个不同的值(如，客户端请求一个较短的连接标识符)。  
 - 0x30 的这两位共同表示了当前包序号所使用的字节数。这个标志位一般用在帧的包中。对于重置和版本协商包(服务端发出)不需要包序号，因此这两位没有使用必须置为0。  
 这两位分别表示：
		- 0x30 表示当前使用6字节的包序号。
		- 0x20 表示当前使用4字节的包序号。
		- 0x10 表示当前使用2字节的包序号。
		- 0x00 表示当前使用1字节的包序号。 
 - 0x40 预留给多路径使用。  
 - 0x80 当前未使用，需要设置为0。  