# 2. 协定和一些定义 #
QUIC使用的所有整型数值都使用小端字节序而非网络序，包括长度值，版本号，类型等。QUIC对于动态大小的数据帧的类型，在内存排布上不需要强制对其。  

以下是文章中使用的一些术语：  

- 客户端：QUIC连接的发起者终端。  
- 服务端：接受到来的QUIC连接的终端。  
- 终端：一个客户端或者服务端的连接。  
- 流：在QUIC连接中传递的双向数据的流动。  
- 连接：两个QUIC终端的会话，多种流将使用同一种加密方法。  
- 连接ID：QUIC连接的标识符。  
- QUIC包：一个可以被接受端解析的合法的UDP载荷。本文档中QUIC包大小可以参考UDP载荷大小。  

# 3. QUIC综述 #
这里我们要描述QUIC的主要机制和优势。QUIC机制上类似TCP+TLS+HTTP/2，但是是基于UDP的实现。QUIC和TCP+TLS+HTTP/2相比，优势如下：  

- 连接建立的延迟  
- 灵活的拥塞控制  
- 消除了head-of-line blocking的多路复用。[[HOL](https://en.wikipedia.org/wiki/Head-of-line_blocking)]  
- 经认证且加密的消息头和载荷  
- 流和连接的流量控制  
- 连接迁移  

## 3.1 连接建立的延迟 ##
QUIC合并了加密和传输握手，降低了不少建立加密连接所需要的消息交互来回次数。传统的TCP+TLS在发送数据之前需要经历1-3个来回的信息交互(注：这里应该包括了TLS交换密钥的握手和TCP的三次握手)，与之相比，QUIC连接一般是0-RTT的，大部分QUIC连接，数据将被直接发送，不需要等待服务端的响应。  

QUIC使用了专用流(STREAM ID 1)来执行握手，但是具体的握手协议本文不进行描述。具体详见参考文档[2].QUIC当前的握手方式将在未来被TLS 1.3所替代。  

注：[[TLS 1.3 Zero-RTT](https://tlswg.github.io/tls13-spec/)]

## 3.2 灵活的拥塞控制 ##
QUIC拥有可扩展的拥塞控制，和TCP相比，提供了更多的信令，这让QUIC可以为拥塞控制算法提供更多的信息。当前默认的拥塞控制与TCP相同。我们正在实验一些可以替代TCP的拥塞控制算法。

举其中一个例子，我们在所有包(包括普通包和重传包)种加入了一个新的包序列号。这使得QUIC的发送方可以区分重传和普通的ACK报文，可以避免TCP的重传二义性问题。QUIC的ACK报文携带了从包被接收到确认报文被发送的延迟，以及一个单调递增的包号，这些都可以提高RTT的计算精度。  

/* TODO  */  
最后，QUIC的ACK帧支持最多256个ack块，因此QUIC在重排上相较于TCP的SACK更加具有弹性(TODO....)，也可以在丢包或者乱序时候保持更多的包。同时客户端和服务端也都能更准确的知道对端的接收信息。  



